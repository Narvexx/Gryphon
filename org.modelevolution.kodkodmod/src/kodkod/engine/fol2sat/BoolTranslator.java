/*
 * Kodkod -- Copyright (c) 2005-present, Emina Torlak KodkodMod -- Copyright (c)
 * 2014-present, Sebastian Gabmeyer
 * 
 * Nota bene: A lot of the code contained in this class was taken from the
 * kodkod.engine.fol2sat.Translator class of which Emina Torlak is the copyright
 * holder.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package kodkod.engine.fol2sat;

import static kodkod.engine.fol2sat.FormulaFlattener.flatten;
import static kodkod.engine.fol2sat.Skolemizer.skolemize;
import static kodkod.util.nodes.AnnotatedNode.annotate;

import java.util.Collections;
import java.util.IdentityHashMap;
import java.util.Map;
import java.util.Set;

import kodkod.ast.Formula;
import kodkod.ast.Node;
import kodkod.ast.Relation;
import kodkod.ast.RelationPredicate;
import kodkod.ast.visitor.AbstractReplacer;
import kodkod.engine.bool.BooleanConstant;
import kodkod.engine.bool.BooleanFactory;
import kodkod.engine.config.ExtOptions;
import kodkod.instance.Bounds;
import kodkod.instance.TupleSet;
import kodkod.util.ints.IndexedEntry;
import kodkod.util.ints.IntSet;
import kodkod.util.nodes.AnnotatedNode;

import org.modelevolution.commons.modifications.BasedOn;
import org.modelevolution.commons.modifications.ModType;
import org.modelevolution.commons.modifications.Modification;
import org.modelevolution.commons.modifications.ModifiedBy;

/**
 * A <b>non-incremental, verbosely logging</b> translator that translates an
 * {@linkplain Formula} into a Boolean circuit.
 * 
 * @see CustomMemoryLogger
 * 
 * @author Sebastian Gabmeyer
 * 
 */
@ModifiedBy("Sebastian Gabmeyer")
@Modification(ModType.NEW)
@BasedOn(Translator.class)
public final class BoolTranslator {
  private final ExtOptions options;
  private final boolean incremental = false;
  private final Bounds originalBounds;
  private final Bounds bounds;

  public BoolTranslator(Bounds bounds, ExtOptions options) {
    this.originalBounds = bounds;
    this.bounds = bounds.clone();
    this.options = options;
  }

  // public TranslationLogger logger() {
  // return logger;
  // }

  /*
   * (non-Javadoc)
   * 
   * @see kodkodmod.engine.fol2aig.Linguist#translate(kodkod.ast.Formula,
   * kodkod.instance.Bounds, kodkod.engine.config.Options)
   */
  @ModifiedBy("Sebastian Gabmeyer")
  @Modification(ModType.BODY)
  public BoolTranslation translate(AnnotatedNode<Formula> conjuncts) {
    // Remove bindings for unused relations/ints if this is not an
    // incremental translation. If it is
    // an incremental translation, we have to keep all bindings since they
    // may be used later on.
    bounds.relations().retainAll(conjuncts.relations());
    if (!conjuncts.usesInts())
      bounds.ints().clear();
    // Detect symmetries.
    final SymmetryBreaker breaker = new SymmetryBreaker(bounds, options.reporter());
    // Optimize formula and bounds by using symmetry information to tighten
    // bounds and
    // eliminate top-level predicates, and also by skolemizing. Then
    // translate the optimize
    // formula and bounds to a circuit, augment the circuit with a symmetry
    // breaking predicate
    // that eliminates any remaining symmetries, and translate everything to
    // CNF.
    return toBoolean(optimizeFormulaAndBounds(conjuncts, breaker), breaker);
  }

  /**
   * Translates the given annotated formula to a circuit, conjoins the circuit
   * with an SBP generated by the given symmetry breaker, and returns its
   * {@linkplain Translation} to CNF. The SBP breaks any symmetries that could
   * not be broken during the
   * {@linkplain #optimizeFormulaAndBounds(AnnotatedNode, SymmetryBreaker)
   * formula and bounds optimization} step.
   * 
   * @requires SAT(annotated.node, this.bounds, this.options) iff
   *           SAT(this.originalFormula, this.originalBounds, this.options)
   * @requires breaker.bounds = this.bounds
   * @ensures this.options.logTranslation => some this.log'
   * @ensures this.options.reporter().translatingToBoolean(annotated.node(),
   *          this.bounds)
   * @ensures this.options.reporter().generatingSBP()
   * @return the translation of annotated.node with respect to this.bounds
   * 
   */
  /**
   * @param annotated
   * @param breaker
   * @return
   */
  private BoolTranslation toBoolean(AnnotatedNode<Formula> annotated, SymmetryBreaker breaker) {

    options.reporter().translatingToBoolean(annotated.node(), bounds);

    LeafInterpreter interpreter = LeafInterpreter.exact(bounds, options.baseOptions(), incremental);
    final BooleanFactory factory = interpreter.factory();

    /*
     * Executed only for its side-effect, namely the logging of the translation
     * by the option's logger
     */    
    FOL2BoolTranslator.translate(annotated, interpreter, options.logger());
    final ExtTranslationLog log = options.logger().log();
    /*
     * if (circuit.isShortCircuited()) { return
     * trivial(circuit.op().shortCircuit(), log); } else if (circuit.size() ==
     * 0) { return trivial(circuit.op().identity(), log); }
     */
    // // TODO: Remove the next 3 lines
    // System.out.println("Circuit w/o SBP:");
    // System.out.println(circuit.toString());
    // System.out.println();
    // circuit.add(breaker.generateSBP(interpreter, options.baseOptions()));
    // // TODO: Remove the next 3 lines
    // System.out.println("Circuit w/ SBP:");
    // System.out.println(circuit.toString());
    // System.out.println();

    final int maxVariable = interpreter.factory().maxVariable();
    final int maxFormula = interpreter.factory().maxFormula();
    final Map<Relation, IntSet> varUsage = interpreter.vars();
    interpreter = null; // enable gc
    return new BoolTranslation((ExtTranslationLog) log, /*
                                                         * @see
                                                         * Translator#toBoolean(
                                                         * AnnotatedNode
                                                         * ,SymmetryBreaker )
                                                         */
    completeBounds(), varUsage, maxVariable, maxFormula);
  }

  /**
   * <p>
   * When logging is disabled, optimizes annotated.node by first breaking matrix
   * symmetries on its top-level predicates, replacing them with the simpler
   * formulas generated by
   * {@linkplain SymmetryBreaker#breakMatrixSymmetries(Map, boolean)
   * breaker.breakMatrixSymmetries(...)}, and skolemizing the result, if
   * applicable.
   * </p>
   * 
   * <p>
   * When logging is enabled, optimizes annotated.node by first flattening it
   * into a set of conjuncts, assuming that core granularity is 1. This involves
   * pushing negations through quantifier-free formulas. We then skolemize,
   * followed by an additional layer of flattening (if
   * this.options.coreGranularity > 1), possibly through quantifiers (if
   * this.options.coreGranuarity is 3). Predicate inlining and breaking of
   * matrix symmetries is performed last to prevent any quantified formulas
   * generated by predicate inlining from also being flattened (as this wouldn't
   * be meaningful at the level of the original formula).
   * </p>
   * 
   * @requires SAT(annotated.node, this.bounds, this.options) iff
   *           SAT(this.originalFormula, this.originalBounds, this.options)
   * @requires annotated.node.*components & Relation =
   *           this.originalFormula.*components & Relation
   * @requires breaker.bounds = this.bounds
   * @ensures this.bounds.relations in this.bounds.relations'
   * @ensures this.options.reporter().optimizingBoundsAndFormula()
   * @return some f: AnnotatedNode<Formula> | meaning(f.node, this.bounds,
   *         this.options) = meaning(this.originalFormula, this.originalBounds,
   *         this.options)
   */
  private AnnotatedNode<Formula> optimizeFormulaAndBounds(AnnotatedNode<Formula> annotated,
      SymmetryBreaker breaker) {
    options.reporter().optimizingBoundsAndFormula();

    if (options.logTranslation() > 0) {
      final int coreGranularity = options.coreGranularity();
      if (coreGranularity == 1) {
        annotated = flatten(annotated, false);
      }
      if (options.skolemDepth() >= 0) {
        annotated = skolemize(annotated, bounds, options.baseOptions());
      }
      if (coreGranularity > 1) {
        annotated = flatten(annotated, options.coreGranularity() == 3);
      }
      return inlinePredicates(annotated,
                              breaker.breakMatrixSymmetries(annotated.predicates(), false));
    } else {
      annotated = inlinePredicates(annotated,
                                   breaker.breakMatrixSymmetries(annotated.predicates(), true)
                                          .keySet());
      return options.skolemDepth() >= 0 ? Skolemizer.skolemize(annotated, bounds,
                                                               options.baseOptions()) : annotated;
    }
  }

  /**
   * Returns an annotated formula f such that f.node is equivalent to
   * annotated.node with its <tt>truePreds</tt> replaced with the constant
   * formula TRUE and the remaining predicates replaced with equivalent
   * constraints.
   * 
   * @requires truePreds in annotated.predicates()[RelationnPredicate.NAME]
   * @requires truePreds are trivially true with respect to this.bounds
   * @return an annotated formula f such that f.node is equivalent to
   *         annotated.node with its <tt>truePreds</tt> replaced with the
   *         constant formula TRUE and the remaining predicates replaced with
   *         equivalent constraints.
   */
  private AnnotatedNode<Formula> inlinePredicates(final AnnotatedNode<Formula> annotated,
      final Set<RelationPredicate> truePreds) {
    final AbstractReplacer inliner = new AbstractReplacer(annotated.sharedNodes()) {
      public Formula visit(RelationPredicate pred) {
        Formula ret = lookup(pred);
        if (ret != null)
          return ret;
        return truePreds.contains(pred) ? cache(pred, Formula.TRUE) : cache(pred,
                                                                            pred.toConstraints());
      }
    };
    return annotate(annotated.node().accept(inliner));
  }

  /**
   * Returns an annotated formula f such that f.node is equivalent to
   * annotated.node with its <tt>simplified</tt> predicates replaced with their
   * corresponding Formulas and the remaining predicates replaced with
   * equivalent constraints. The annotated formula f will contain transitive
   * source information for each of the subformulas of f.node. Specifically, let
   * t be a subformula of f.node, and s be a descdendent of annotated.node from
   * which t was derived. Then, f.source[t] = annotated.source[s]. </p>
   * 
   * @requires simplified.keySet() in
   *           annotated.predicates()[RelationPredicate.NAME]
   * @requires no disj p, p': simplified.keySet() | simplified.get(p) =
   *           simplifed.get(p') // this must hold in order to maintain the
   *           invariant that each subformula of the returned formula has
   *           exactly one source
   * @requires for each p in simplified.keySet(), the formulas
   *           "p and [[this.bounds]]" and
   *           "simplified.get(p) and [[this.bounds]]" are equisatisfiable
   * @return an annotated formula f such that f.node is equivalent to
   *         annotated.node with its <tt>simplified</tt> predicates replaced
   *         with their corresponding Formulas and the remaining predicates
   *         replaced with equivalent constraints.
   */
  private AnnotatedNode<Formula> inlinePredicates(final AnnotatedNode<Formula> annotated,
      final Map<RelationPredicate, Formula> simplified) {
    final Map<Node, Node> sources = new IdentityHashMap<Node, Node>();
    final AbstractReplacer inliner = new AbstractReplacer(annotated.sharedNodes()) {
      private RelationPredicate source = null;

      protected <N extends Node> N cache(N node, N replacement) {
        if (replacement instanceof Formula) {
          if (source == null) {
            final Node nsource = annotated.sourceOf(node);
            if (replacement != nsource)
              sources.put(replacement, nsource);
          } else {
            sources.put(replacement, source);
          }
        }
        return super.cache(node, replacement);
      }

      public Formula visit(RelationPredicate pred) {
        Formula ret = lookup(pred);
        if (ret != null)
          return ret;
        source = pred;
        if (simplified.containsKey(pred)) {
          ret = simplified.get(pred).accept(this);
        } else {
          ret = pred.toConstraints().accept(this);
        }
        source = null;
        return cache(pred, ret);
      }
    };

    return annotate(annotated.node().accept(inliner), sources);
  }

  /**
   * Returns a whole or incremental translation, depending on the value of
   * {@code this.incremental}, using the given trivial outcome,
   * {@linkplain #completeBounds() completeBounds()}, {@code this.options}, and
   * the given log.
   * 
   * @ensures {@link #completeBounds()}
   * @return some t: Translation | t.bounds = completeBounds() &&
   *         t.originalBounds = this.originalBounds && no t.solver.variables &&
   *         no t.vars && (outcome.booleanValue() => no t.solver.clauses else
   *         (one t.solver.clauses && no t.solver.clauses.literals))
   **/
  @SuppressWarnings("unchecked")
  @Modification(ModType.SIGNATURE)
  @ModifiedBy("Sebastian Gabmeyer")
  private BoolTranslation trivial(BooleanConstant outcome, ExtTranslationLog log) {
    return new BoolTranslation(log, completeBounds(),
                               (Map<Relation, IntSet>) Collections.EMPTY_MAP, 0, 0);
  }

  /**
   * Completes {@code this.bounds} using the bindings from
   * {@code this.originalBounds} so that the result satisfies the
   * {@linkplain Translation} invariants. This involves updating
   * {@code this.bounds} with bindings from {@code this.originalBounds}, if any,
   * that had been discarded in the {@link #translate(AnnotatedNode) first step}
   * of the translation. The first step of a non-incremental translation is to
   * discard bounds for relations that are not constrained by
   * {@code this.originalFormula}, and to discard all integer bounds if
   * {@code this.originalFormula} contains no integer expressions. This is sound
   * since any instance of {@code this.originalFormula} with respect to
   * {@code this.originalBounds} only needs to satisfy the lower bound
   * constraint on each discarded relation/integer. By updating
   * {@code this.bounds} with the bindings for discarded relations/integers for
   * which no variables were allocated, we ensure that any instance returned by
   * {@linkplain Translation#interpret()} will bind those relations/integers to
   * their lower bound, therefore satisfying the original problem
   * {@code (this.originalFormula, this.originalBounds, this.options)}.
   * 
   * @requires no this.bounds.intBound or this.bounds.intBound =
   *           this.originalBounds.intBound
   * @ensures this.bounds.relations' = this.bounds.relations +
   *          this.originalBounds.relations && this.bounds.intBound' =
   *          this.originalBounds.intBound && this.bounds.lowerBound' =
   *          this.bounds.lowerBound + (this.originalBounds.relations -
   *          this.bounds.relations)<:(this.originalBounds.lowerBound) &&
   *          this.bounds.upperBound' = bounds.upperBound +
   *          (this.originalBounds.relations -
   *          this.bounds.relations)<:(this.originalBounds.upperBound)
   * @return this.bounds
   */
  private Bounds completeBounds() {
    final Bounds optimized = this.bounds;
    final Bounds original = this.originalBounds;
    if (optimized.ints().isEmpty()) {
      for (IndexedEntry<TupleSet> entry : original.intBounds()) {
        optimized.boundExactly(entry.index(), entry.value());
      }
    } else {
      assert optimized.intBounds().equals(original.intBounds());
    }
    final Set<Relation> rels = optimized.relations();
    for (Relation r : original.relations()) {
      if (!rels.contains(r)) {
        optimized.bound(r, original.lowerBound(r), original.upperBound(r));
      }
    }
    return optimized;
  }
}
